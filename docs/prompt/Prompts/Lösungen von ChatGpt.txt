Ursachenanalyse

In HuggingFace Spaces führt ein restriktives Bereitstellungs-Umfeld häufig zu einem „schwarzen Bildschirm“: Die Web-App startet (Status “Running”), lädt aber über CSP- und Permissions-Policy-Einstellungen blockierte Ressourcen nicht, so dass die Benutzeroberfläche leer bleibt. Insbesondere treten in der Konsole Warnungen wie “Unrecognized feature: 'ambient-light-sensor'” auf – Hinweise darauf, dass veraltete oder nicht unterstützte Features in der Permissions-Policy verwendet werden. Ebenso weisen viele Permissions-Policy-Fehlermeldungen darauf hin, dass Browser veraltete Direktiven (z.B. legacy-image-formats, battery, document-domain etc.) nicht erkennen. Diese Warnungen sind an sich meist harmlos, können aber die Fehlersuche erschweren. Noch kritischer sind CSP-Verletzungen: So wird oft der Zugriff auf externe Skripte oder Ressourcen unterbunden. Beispielsweise bricht ein <script src="https://cdn.jsdelivr.net/npm/…"> die App, wenn cdn.jsdelivr.net nicht im CSP-Header oder Meta-Tag erlaubt ist. Ähnliche Blockierungen treffen Fonts (Google Fonts), JSON- oder GLB-Dateien von CDNs usw. Fehlende Web-Worker (Blob-)Erlaubnis führt zudem dazu, dass über new Worker(...) geladene Module nicht ausgeführt werden. Schließlich sind browserseitige Funktionen wie SharedArrayBuffer standardmäßig abgeschaltet („SharedArrayBuffer: ❌ NO“), da Spaces ohne spezielle Header ausgeliefert werden – das verhindert leistungsstarke WebAssembly-Threads. Auch wenn diese Punkte nicht alle unmittelbar zum UI-Ausfall führen, tragen sie zu einer instabilen Ausführungsumgebung bei. (Näheres zu den Sperr-Mechanismen siehe unten.)

Technische Details

Permissions-Policy-Warnungen: Ältere Feature-Policy-Direktiven wie ambient-light-sensor, battery, layout-animations, legacy-image-formats usw. wurden von modernen Browsern entfernt. Wenn diese in einem <meta http-equiv="Permissions-Policy"> (oder HTTP-Header) stehen, meldet die Konsole Warnungen wie in [Really-amin/Dashboard-Fix] beschrieben. Diese Zeilen sind in der Regel nur Warnungen – sie blockieren keine Kernelemente der App. Problematisch wird es aber, wenn etwa sync-xhr=() gesetzt wird (sieh [Crypto-Hub] oben), denn dadurch sind synchroner XMLHttpRequest oder bestimmte Bild-Formate komplett deaktiviert. Ebenso kann das Ausschließen von wake-lock oder document-domain unerwartetes Verhalten verursachen, wenn die App diese Features nutzt. Im gezeigten Beispiel [Crypto Intelligence Hub auf HF Spaces] wurde daher eine eigene Permissions-Policy über <meta> eingebunden, die nur anerkannte Features listet, um Browser-Warnungen zu vermeiden. Eine andere Strategie (wie im Crypto-Dashboard-Fix) ist das vollständige Entfernen der Policy-Zeile.

Content Security Policy (CSP): HuggingFace Spaces setzen standardmäßig sehr enge CSP-Header. Ohne Anpassung darf die App z.B. nur Ressourcen von self laden. Externe JS/CDN-Links (jsDelivr, unpkg o.Ä.) oder Schriftarten werden abgeblockt. In der obigen Server-Konfiguration wird deshalb CSP explizit gelockert: Es werden etwa blob: als Quelle für <script> und WebWorker erlaubt, fonts.googleapis.com/fonts.gstatic.com für Schriftarten, und https://*.gstatic.com für Bilder. Fehlt das, schlägt schon das Nachladen einer externen Datei fehl (im Browser erscheint z.B. „Refused to load the script … because it violates the following Content Security Policy“). Ähnliches gilt für fetch/Fetch-API: Ist der Endpunkt nicht in connect-src erlaubt, scheitert der Datenabruf still. Auch das Frame-Busting der Spaces (sie laufen oft in einem Iframe) kann über frame-ancestors Probleme machen. Zusammenfassend führen also CSP-Verletzungen (Fonts, Module, Bilder, Worker) zu einem vollständigen Funktionsausfall der UI.

Veraltete Parameter: In Chrome’s GPU-Info oder DevTools findet man oft Zeilen wie SharedArrayBuffer: ❌ NO oder legacy-image-formats: ❌ NO. Das ist kein direkter Fehler der App, sondern ein Indikator fehlender Cross-Origin-Isolation. Ohne spezielle Header (Cross-Origin-Embedder-Policy, Cross-Origin-Opener-Policy) sind SharedArrayBuffer oder neuere Bildcodecs deaktiviert. Nur wenn die entsprechenden Header im Space-Config (via custom_headers) gesetzt werden, kann man z.B. Multithreading (Wasmb mit SharedArrayBuffer) nutzen. Ansonsten sollten Entwickler prüfen, ob ihre Three.js-App auf solche Features angewiesen ist. Legacy-Image-Formate (z.B. ältere JPEG/PNG) sind üblicherweise zugelassen, aber wenn sie in einer Policy deaktiviert werden, können Texturen oder Bilder aus diesem Grund fehlen.

Sonstige Aspekte: Oft führen auch falsche Build/Deploy-Parameter zum Ausfall: Beispielhaft muss der Node/Express-Server im Docker-Space auf process.env.PORT (standardmäßig 7860) lauschen. Feste Ports oder fehlende CORS-Header blockieren Verbindungstests oder WebSocket-Aufrufe (im Crypto-Dashboard wurden deshalb WebSocket-URLs dynamisch mit wss:// erzeugt). Eingesetzte Bibliotheken wie Chart.js sollten per defer eingebunden werden, damit sie die Rendering-Pipeline nicht blockieren. Fehlt dies, kann auch ein lange ladendes Skript auf jsDelivr den Initialrender aufhalten.

Lösungsansätze und Workarounds

Permissions-Policy anpassen: Entferne veraltete Direktiven oder nutze eine stark reduzierte Policy. Entweder löscht man ganz den <meta http-equiv="Permissions-Policy"> (wie im Crypto-Fixbericht empfohlen) oder man definiert im Header nur noch aktuelle Features. Im obigen Beispiel wurde eine Policy per Meta-Tag eingefügt, die nur anerkanntes Feature-Set enthält (alles andere ist () gesetzt). Das beseitigt zumindest die Fehlermeldungen.

CSP erweitern: Wenn Du eine Docker/App-Server-Struktur verwendest, setze in Deinem Server (z.B. Express) einen CSP-Header, der alle benötigten Domains einbezieht. Erlaube insbesondere blob: in script-src und worker-src (wichtig für dynamische Imports oder WebWorkers) sowie die Domains Deiner externen Assets (z.B. https://cdn.jsdelivr.net oder https://fonts.googleapis.com) . Als Beispiel fügte man obigen CSP-Header „script-src 'self' ... blob: … font-src https://fonts.gstatic.com …“ hinzu. Bei statischen Spaces (Static HTML) ist das schwieriger – dort muss man Ressourcen ggf. lokal einbinden oder ein sogenanntes manifest.json für erlaubte CDNs bereitstellen.

Ressourcen lokal hosten: Eine einfache Strategie ist, kritische Skripte/Modelle vorzuverlagern. So umgeht man CSP-Probleme. Beispielsweise kann man Three.js lokal kopieren oder Modelle in den Space-Ordner legen, statt sie von jsDelivr zu importieren. Auch Chart.js kann lokal eingebunden werden – dann entfällt auch das notwendige defer von externen Skripten.

Cross-Origin-Isolation aktivieren: Falls Deine App multithreadingfähige WebAssembly oder SharedArrayBuffer braucht, setze in README.md der Space unter custom_headers: folgende Einträge (alles kleingeschrieben):

cross-origin-embedder-policy: require-corp
cross-origin-opener-policy: same-origin
cross-origin-resource-policy: cross-origin

Damit wird der Browser isoliert und SharedArrayBuffer verfügbar. Fehlt das, musst Du Deine Render-Strategie ggf. so anpassen, dass kein Multi-Threading nötig ist.

CORS einrichten: Wenn Deine App Daten von anderen Domains bezieht (z.B. WebSockets, API-Calls), stelle sicher, dass Access-Control-Allow-Origin: * oder die konkrete Domain gesetzt ist. Im obigen Node-Server wurde über cors: { origin: "*" } oder ein ENV-Variable sichergestellt, dass WebSocket- und HTTP-Calls nicht an CORS scheitern.

Debuggen und Dokumentation: Konsolenfehler und Logging sind entscheidend. Manche Spaces-Entwickler unterdrücken harmloses Console-Rauschen (wie „Unrecognized feature“ Warnungen), indem sie eigene Skripte verwenden. Gleichzeitig sollten echte Fehler (404 auf Assets, JS-Syntaxfehler, WebSocket-Ausfall) sichtbar bleiben. Im Crypto-Fixbericht finden sich weitere Hinweise – etwa die Anpassung der WebSocket-URL auf wss:// oder das korrekte Lesen des PORT-Umgebungsparameters.

Empfehlungen

Aus den Erfahrungen empfiehlt es sich, schon beim Entwicklungsstart die Sonderheiten von HuggingFace Spaces zu berücksichtigen. Prüfe nach dem Deploy die Browser-Konsole: CSP-Verletzungen oder Zugriffsfehler (Refused to load …) deuten auf fehlende Ressourcen-Erlaubnis hin. Stelle sicher, dass alle genutzten CDN-Domains in der CSP (oder in statischen Manifesten) freigegeben sind. Benutze, wenn möglich, lokale Dateien oder eingebetteten Code für kritische Assets. Entferne obsolet gewordene Permissions-Policy-Direktiven (oder nutze nur eine minimale Policy), damit die Warnungen nicht von echten Fehlern ablenken. Falls nötig, wechsle auf ein Docker-basiertes Setup mit Express/Webserver, wo Du Header beliebig setzen kannst – so wie im Beispiel, das blob:, Google-Schriftarten usw. explizit erlaubt. Dokumentierte Lösungen aus GitHub und HF-Foren (z.B. Anpassung von <script>-Tags, CORS-Header oder Deployment-Konfigurationen) können direkt übernommen werden. Mit dieser Kombination aus CSP-Korrekturen, Policy-Optimierungen und lokalen Ressourcen lässt sich ein „blank screen“ in vielen Fällen vermeiden.

Quellen: Fehlermeldungs- und Fix-Reports aus echten HuggingFace Spaces (z.B. Crypto-Dashboard-Fix) sowie Beispiele für angepasste Server-Header und offizielle HF-Dokumentation zu Cross-Origin-Policies. These refer to the content and resolution of UI rendering issues in Spaces.