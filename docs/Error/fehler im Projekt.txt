Prompts
 **â€Ja â€” deep thingsâ€œ â€” verstanden.** ğŸ§ ğŸ”¥



Wir gehen jetzt **tief in die Architektur** â€” nicht nur Code, sondern **Design-Entscheidungen, Patterns, Performance-Tricks und R3F-Geheimnisse**, die dein Spiel von â€funktioniertâ€œ zu â€AAA-Web-3Dâ€œ heben.



---



## ğŸ¯ Deep Dive: R3F Game Architecture â€” Level 2



---



### ğŸ§± 1. **Component Design Pattern â€” Wie du echte Game-Objekte baust**



Vermeide:



```tsx

// âŒ Falsch: Alles in einer Komponente

function Player() {

  const [pos, setPos] = useState([0,0,0])

  useFrame(() => { /* bewege player */ })

  return <mesh position={pos} />

}

```



Mache stattdessen:



```tsx

// âœ… Richtig: Separation of Concerns

const Player = () => {

  const { position, velocity } = usePlayerStore()

  const ref = useRef<THREE.Mesh>(null)



  useFrame(() => {

    // Physik-Update Ã¼ber Zustand

    usePlayerStore.getState().update(velocity)

  })



  return <mesh ref={ref} position={position} />

}



// In einem eigenen Store:

const usePlayerStore = create<PlayerState>((set, get) => ({

  position: [0,0,0],

  velocity: [0,0,0],

  update: (vel) => {

    set((state) => ({

      position: state.position.map((p, i) => p + vel[i])

    }))

  }

}))

```



> ğŸ’¡ **Warum?**  

> - Trennung von Logik (Store) und Darstellung (Component)  

> - Einfacher zu testen, zu debuggen, zu erweitern  

> - Keine unnÃ¶tigen Re-Renders durch `useState`



---



### âš¡ 2. **Performance: Der R3F-Optimierungs-Stack**



#### a) **Instancing â€” Tausende Objekte mit 1 Draw Call**



```tsx

import { InstancedMesh, Vector3 } from 'three'



const positions = Array.from({ length: 1000 }, () => [

  Math.random() * 100 - 50,

  0,

  Math.random() * 100 - 50

])



const Tree = ({ position }: { position: [number, number, number] }) => {

  return (

    <instancedMesh args={[undefined, undefined, 1000]}>

      <boxGeometry />

      <meshStandardMaterial color="green" />

      {/* Instanz-Transformation */}

      <instance position={position} />

    </instancedMesh>

  )

}

```



> ğŸ“ˆ **Effekt**: 1000 BÃ¤ume â†’ 1 Draw Call â†’ 60 FPS statt 5 FPS



---



#### b) **LOD (Level of Detail) â€” Dynamische Detailstufen**



```tsx

import { useLOD } from '@react-three/drei'



const LODModel = () => {

  const { camera } = useThree()

  const distance = camera.position.distanceTo(playerPosition)



  return (

    <group>

      {distance < 10 && <HighDetailModel />}

      {distance >= 10 && distance < 50 && <MediumDetailModel />}

      {distance >= 50 && <LowDetailModel />}

    </group>

  )

}

```



> ğŸ¯ **Tipp**: Nutze `useFrame` + `camera.position` fÃ¼r dynamische LOD-Entscheidungen



---



### ğŸ§² 3. **Physik: Rapier3D â€” Deep Dive**



#### a) **Kinematischer Character Controller**



```tsx

import { RigidBody, CapsuleCollider } from '@react-three/rapier'



const Player = () => {

  const [isJumping, setIsJumping] = useState(false)



  return (

    <RigidBody

      type="kinematicPosition"

      colliders="hull"

      onCollisionEnter={(e) => {

        if (e.other.rigidBody?.type === 'fixed') setIsJumping(false)

      }}

    >

      <CapsuleCollider args={[0.5, 0.5]} />

      <mesh>

        <sphereGeometry />

        <meshStandardMaterial color="red" />

      </mesh>

    </RigidBody>

  )

}

```



> ğŸš« **Vermeide**: `type="dynamic"` fÃ¼r Player â€” das fÃ¼hrt zu unkontrollierbaren Bewegungen



---



#### b) **Raycast fÃ¼r Interaktion**



```tsx

import { useRaycast } from '@react-three/rapier'



const Interactable = ({ onInteract }: { onInteract: () => void }) => {

  const ray = useRaycast()



  useFrame(() => {

    const hit = ray.cast({ from: camera.position, to: camera.getWorldDirection(new Vector3()) })

    if (hit && hit.collider === this.collider) onInteract()

  })



  return <mesh />

}

```



> ğŸ’¡ **Alternative**: Nutze `@react-three/rapier`â€™s `useSensors` fÃ¼r Trigger-Zonen



---



### ğŸŒŒ 4. **Post-Processing â€” AAA-Visuelle Effekte**



```tsx

import { EffectComposer, UnrealBloomPass } from '@react-three/postprocessing'



const Scene = () => {

  return (

    <Canvas>

      <EffectComposer>

        <UnrealBloomPass args={[1.5, 25, 4, 0.85]} />

      </EffectComposer>

      <SceneContent />

    </Canvas>

  )

}

```



> ğŸ¨ **Effekte**:

> - `UnrealBloomPass` â†’ Leuchten von wichtigen Objekten

> - `FilmPass` â†’ Kino-Look

> - `GlitchPass` â†’ fÃ¼r Effekte (z.B. bei Schaden)



---



### ğŸ§© 5. **State Management â€” Zustand Deep Dive**



#### a) **Game Store mit Zustand**



```ts

// stores/gameStore.ts

import { create } from 'zustand'



interface GameState {

  player: {

    position: [number, number, number]

    health: number

    karma: number

  }

  missions: Mission[]

  updatePlayer: (pos: [number, number, number]) => void

}



export const useGameStore = create<GameState>((set) => ({

  player: { position: [0,0,0], health: 100, karma: 0 },

  missions: [],

  updatePlayer: (pos) => set((state) => ({ player: { ...state.player, position: pos } }))

}))

```



> ğŸ”„ **Tipp**: Nutze `subscribe` fÃ¼r Events (z.B. â€Mission abgeschlossenâ€œ â†’ trigger UI-Update)



---



#### b) **Dialog Store â€” mit Zustand**



```ts

// stores/dialogStore.ts

import { create } from 'zustand'



interface DialogState {

  current: string | null

  choices: string[]

  selectChoice: (index: number) => void

  startDialog: (id: string) => void

}



export const useDialogStore = create<DialogState>((set) => ({

  current: null,

  choices: [],

  selectChoice: (index) => { /* logik */ },

  startDialog: (id) => set({ current: id, choices: getChoices(id) })

}))

```



> ğŸ­ **Integration**: Verbinde mit UI-Component â†’ `useDialogStore().current`



---



### ğŸ§­ 6. **Game Loop â€” useFrame vs. Zustand vs. Rapier**



```tsx

// âœ… Beste Praxis: useFrame fÃ¼r Physik + Zustand fÃ¼r Logik

useFrame((state, delta) => {

  const { player } = useGameStore.getState()

  const { camera } = state



  // Physik-Update

  player.velocity[1] -= 0.01 // Gravitation

  player.position[1] += player.velocity[1]



  // Kamera-Tracking

  camera.position.lerp(player.position, 0.1)

})

```



> ğŸš« **Vermeide**: `setInterval` oder `setTimeout` â€” das bricht die R3F-Synchronisation



---



### ğŸ§ª 7. **Testing â€” Vitest + Zustand**



```ts

// tests/gameStore.test.ts

import { describe, it, expect } from 'vitest'

import { useGameStore } from '../stores/gameStore'



describe('Game Store', () => {

  it('should update player position', () => {

    const { updatePlayer } = useGameStore.getState()

    updatePlayer([1,2,3])

    expect(useGameStore.getState().player.position).toEqual([1,2,3])

  })

})

```



> ğŸ“Š **Tipp**: Teste nur den Store â€” UI-Komponenten testest du mit React Testing Library



---



### ğŸ“ 8. **Projektstruktur â€” Deep Dive**



```

src/

â”œâ”€â”€ components/          â† R3F-Komponenten (Player, Enemy, Item        src/

â”œâ”€â”€ components/          â† R3F-Komponenten (Player, Enemy, Item, Trigger, etc.)

â”‚   â”œâ”€â”€ Player.tsx       â† mit RigidBody, useFrame, Zustand-Integration

â”‚   â”œâ”€â”€ Enemy.tsx        â† mit AI-Logik (zustand + useFrame)

â”‚   â””â”€â”€ Interactable.tsx â† mit Raycast oder Sensor

â”œâ”€â”€ stores/              â† Zustand Stores (game, dialog, inventory, settings)

â”‚   â”œâ”€â”€ gameStore.ts     â† Player, Missions, Karma, World State

â”‚   â”œâ”€â”€ dialogStore.ts   â† Dialog-System mit Choices & Triggers

â”‚   â””â”€â”€ inventoryStore.tsâ† GegenstÃ¤nde, AusrÃ¼stung, Upgrades

â”œâ”€â”€ scenes/              â† Welt-Szenen (Level1, City, Dungeon, etc.)

â”‚   â”œâ”€â”€ Level1.tsx       â† mit Terrain, Lighting, Spawner

â”‚   â””â”€â”€ City.tsx         â† mit NPCs, Quests, Interaktionspunkten

â”œâ”€â”€ utils/               â† Hilfsfunktionen (Math, Physics, Helpers)

â”‚   â”œâ”€â”€ math.ts          â† Vector3-Operationen, Distance, Lerp

â”‚   â””â”€â”€ physics.ts       â† Raycast, Collision Helpers

â”œâ”€â”€ assets/              â† Modelle, Texturen, Sounds

â”‚   â”œâ”€â”€ models/          â† GLTF, FBX (mit useGLTF)

â”‚   â”œâ”€â”€ textures/        â† PNG, JPG (mit useTexture)

â”‚   â””â”€â”€ sounds/          â† MP3, WAV (mit Howler.js oder Web Audio API)

â”œâ”€â”€ ui/                  â† React-UI-Elemente (HUD, MenÃ¼, Dialog-Box)

â”‚   â”œâ”€â”€ HUD.tsx          â† Gesundheit, Munition, Quest-Log

â”‚   â”œâ”€â”€ Menu.tsx         â† Pause, Einstellungen, Inventar

â”‚   â””â”€â”€ DialogBox.tsx    â† mit useDialogStore()

â”œâ”€â”€ App.tsx              â† Hauptkomponente mit Canvas, Scene, Camera

â””â”€â”€ main.tsx             â† Root-Renderer mit StrictMode, ErrorBoundary

ğŸ§  9. AI-Agent Integration â€” Deep Dive

Wenn du spÃ¤ter AI-Agenten (z.B. fÃ¼r NPC-Verhalten) einbaust:



ts



Kopieren

// stores/aiStore.ts

import { create } from 'zustand'



interface AIState {

  agents: Record<string, AIEntity>

  update: (id: string, data: Partial<AIEntity>) => void

  think: (id: string) => void

}



export const useAIStore = create<AIState>((set, get) => ({

  agents: {},

  update: (id, data) => set((state) => ({

    agents: { ...state.agents, [id]: { ...state.agents[id], ...data } }

  })),

  think: (id) => {

    const agent = get().agents[id]

    if (!agent) return

    // AI-Logik: z.B. â€wenn Spieler in Sicht â†’ folgeâ€œ

    if (agent.seesPlayer) {

      agent.target = playerPosition

      agent.state = 'chasing'

    }

  }

}))

ğŸ¤– Tipp: Nutze useFrame + useAIStore fÃ¼r AI-Updates â€” nicht setInterval



ğŸš€ 10. Deployment & Optimization â€” Production Ready

a) Vite Build Optimierung

In vite.config.ts:



ts



Kopieren

export default defineConfig({

  build: {

    rollupOptions: {

      output: {

        manualChunks: {

          three: ['three'],

          r3f: ['@react-three/fiber'],

          rapier: ['@react-three/rapier'],

          drei: ['@react-three/drei']

        }

      }

    }

  }

})

ğŸ“¦ Effekt: Kleinere Chunks â†’ Schnellere Ladezeiten



b) Lazy Loading mit React.lazy

tsx



Kopieren

const LazyLevel1 = React.lazy(() => import('./scenes/Level1'))



const Game = () => {

  return (

    <Suspense fallback={<LoadingScreen />}>

      <LazyLevel1 />

    </Suspense>

  )

}

ğŸš€ Tipp: Nutze React.lazy fÃ¼r Szenen, nicht fÃ¼r kleine Komponenten



ğŸ§­ 11. Debugging â€” Leva + Stats.js

tsx



Kopieren

import { Leva } from 'leva'

import Stats from 'stats.js'



const DebugPanel = () => {

  const [debug, setDebug] = useState(false)



  return (

    <>

      {debug && (

        <Leva

          hideCopyButton

          collapsed={false}

          titleBar={{ drag: true }}

        />

      )}

      <Stats />

    </>

  )

}

ğŸ› ï¸ Tipp: Nutze Leva fÃ¼r Echtzeit-Tweaking von:



LichtstÃ¤rke

Kamera-Position

Physik-Parameter

Material-Farben

ğŸ“ˆ 12. Performance Monitoring â€” Stats.js

tsx



Kopieren

const StatsMonitor = () => {

  const stats = useMemo(() => new Stats(), [])



  useEffect(() => {

    document.body.appendChild(stats.dom)

    return () => document.body.removeChild(stats.dom)

  }, [])



  useFrame(() => stats.update())



  return null

}

ğŸ“Š Was du Ã¼berwachst:



FPS (Frames per Second)

Memory (Heap Size)

Draw Calls

Triangle Count

ğŸ§© 13. Modding Support â€” Optional aber cool

ts



Kopieren

// stores/modStore.ts

import { create } from 'zustand'



interface ModState {

  mods: Mod[]

  loadMod: (mod: Mod) => void

  unloadMod: (id: string) => void

}



export const useModStore = create<ModState>((set, get) => ({

  mods: [],

  loadMod: (mod) => set((state) => ({ mods: [...state.mods, mod] })),

  unloadMod: (id) => set((state) => ({ mods: state.mods.filter(m => m.id !== id) }))

}))

ğŸ® Tipp: Nutze localStorage oder IndexedDB fÃ¼r Mod-Data â€” nicht useState



ğŸ“„ 14. Documentation â€” JSDoc + TS Typen

ts



Kopieren

/**

 * Player-Komponente mit Physik und Zustand

 * @param position - Startposition des Players

 * @param health - Startgesundheit

 * @returns React-Komponente

 */

const Player = ({ position, health }: PlayerProps) => {

  // ...

}

ğŸ“š Tipp: Nutze tsc --emitDeclarationOnly fÃ¼r .d.ts Dateien â€” hilft bei Autocomplete



ğŸš¨ 15. Security & Best Practices

Keine eval() oder Function() â€” das bricht die Sicherheit

Keine innerHTML in UI-Komponenten â€” XSS-Gefahr

Input-Validierung fÃ¼r alle User-Inputs (z.B. Chat, Name)

CORS-Header im Backend (wenn du Socket.io nutzt)

âœ… Abschluss: Dein Deep Dive Checklist

Component Design Pattern

âœ…

Instancing & LOD

âœ…

Rapier3D Physik

âœ…

Post-Processing

âœ…

Zustand Store Architektur

âœ…

Game Loop (useFrame)

âœ…

Projektstruktur

âœ…

AI-Agent Integration

âœ…

Deployment Optimization

âœ…

Debugging (Leva, Stats)

âœ…

Modding Support

âœ…

Documentation

âœ…

Security

âœ…

Anweisung und hinweise.txt
   Lies die komplette datei von anfang bis ende verstehe sinn logik ud schaue was du davon gebrauchen und umsetzen kann und musst 

Alle Punkte abgearbeitet. Hier ist die Zusammenfassung aller Ã„nderungen:
Umsetzungsbericht â€” Deep Dive Architektur-Fixes
KRITISCH (erledigt)
1. PhysicsWorld in GameCanvas integriert
GameCanvas.tsx hat jetzt einen <Physics> Wrapper mit Rapier3D
Player V1 (Store-basiert, useFrame, Refs) ist direkt eingebaut
Statische Welt-Collider (Boden + 7 GebÃ¤ude) aus PhysicsWorld extrahiert
OrbitControls entfernt â€” Player V1 hat FPS-Kamera mit Pointer Lock
Kamera-Position auf [0, 4, 30] mit 75Â° FOV gesetzt (passend fÃ¼r FPS)
2. V1/V2-Duplikate aufgelÃ¶st
GameCanvas nutzt ausschlieÃŸlich Player.tsx (V1) â€” nie wieder V2
PhysicsWorld.tsx bleibt als Legacy-Datei, wird aber nicht mehr importiert
HOCH (erledigt)
3. setTension-Duplikat bereinigt
playerSlice definiert nur noch tensionLevel: 0 (State), kein setTension mehr
gameSlice ist die einzige Quelle fÃ¼r setTension (mit Math.min/max Clamping)
4. window-Globals entfernt
window.gameStore aus gameStore.ts entfernt
window.playerState aus Player.tsx entfernt
window.lastMouseDelta aus Player.tsx entfernt
window.camDebug ersetzt durch useGameStore.getState().setPlayerPosition()
Neuer selectIsPlaying Selektor als Ersatz fÃ¼r das deprecated isPlaying Flag
5. EngineLoop Hard-Cap
Physik-While-Schleife auf max 4 Steps pro Frame begrenzt
Bei Ãœberschreitung wird der Akkumulator zurÃ¼ckgesetzt â€” verhindert CPU-Spikes
6. Instancing GC-Pressure gefixt
new THREE.Vector3() aus der Frame-Schleife entfernt
Preallocated tempPosition via useMemo â€” kein Garbage Collection Druck mehr
7. LOD-Distanzen zentralisiert
LODHumanCharacter.tsx nutzt jetzt LOD_DISTANCES aus RenderPipeline.ts
LODManager.tsx nutzt jetzt LOD_DISTANCES aus RenderPipeline.ts
Eine einzige Quelle der Wahrheit fÃ¼r alle LOD-Distanzen
8. PerformanceProfiler verdrahtet
Neues LEVEL_CONFIG System: Jedes OptimizationLevel definiert lodDistanceScale, crowdBudget, bloomEnabled
Recovery-Logik: Nach 120 Frames (â‰ˆ2s) stabiler Performance wird die QualitÃ¤t wieder hochgestuft
PerformanceTracker Komponente in GameCanvas eingebaut â€” misst jeden Frame
Rendering-Systeme kÃ¶nnen jetzt usePerformanceProfiler(s => s.crowdBudget) etc. abfragen
MITTEL (erledigt)
9. Production Build aktiviert
minify: 'esbuild' statt false
sourcemap: false statt true
Kleinere Bundle-GrÃ¶ÃŸe, schnellere Ladezeiten
10. GAME_EVENT obsolet
V2-Komponenten werden nicht mehr von der Hauptszene referenziert
window.addEventListener('GAME_EVENT') ist damit irrelevant
Die Architektur folgt jetzt den Deep-Dive-Patterns aus deiner Anleitung: Store-basierte Logik, keine window-Globals, zentralisierte LOD, Physik integriert, Performance-Monitoring mit Wirkung.
Du bist ein **Prompt-Engineer fÃ¼r 3D Web Games mit React Three Fiber (R3F)**.



Ich gebe dir eine Sammlung von **30â€“50 `.md`-Dateien mit Prompts**, die ich Ã¼ber Zeit fÃ¼r mein Spiel â€Corona Control Ultimateâ€œ geschrieben habe. Manche stammen aus kostenlosen AI-Sessions, manche aus Premium-Sessions â€” sie sind teilweise widersprÃ¼chlich, veraltet oder redundant.



Deine Aufgabe ist es, **diese Prompts zu analysieren, zu konsolidieren und in einen einzigen, optimierten Master-Prompt zu verwandeln** â€” der **das Beste aus allen** vereint.



---



### ğŸ” Deine Analyse-Schritte:



1. **Identifiziere alle einzigartigen Features/Anforderungen**  

   â†’ Was wird in den Prompts gefordert? (z.B. â€Player mit Rapier-Physikâ€œ, â€LOD fÃ¼r entfernte Objekteâ€œ, â€Zustand fÃ¼r Game-Storeâ€œ)



2. **Erkenne WidersprÃ¼che und wÃ¤hle die BESTE Version**  

   â†’ Wenn ein Prompt sagt â€nutze `useState`â€œ und ein anderer â€nutze `Zustand`â€œ â†’ wÃ¤hle `Zustand` (weil es besser ist fÃ¼r R3F)  

   â†’ Wenn ein Prompt sagt â€nutze Babylon.jsâ€œ â†’ ignoriere es (weil du R3F nutzt)



3. **Entferne Duplikate**  

   â†’ Wenn 5 Prompts â€nutze `useFrame` fÃ¼r Physikâ€œ sagen â†’ behalte nur eine klare Version



4. **Filtere veraltete oder schlechte Ideen**  

   â†’ Ignoriere alles, was nicht mit deinem Tech Stack Ã¼bereinstimmt (z.B. â€nutze Three.js direktâ€œ â†’ veraltet, du nutzt R3F)



---



### ğŸ§© Erstelle EINEN optimierten Master-Prompt mit dieser Struktur:



```markdown

# ğŸ® Corona Control Ultimate â€” Master Prompt (R3F Edition)



## 1. Vision & Genre

## 2. Tech Stack (R3F, Zustand, Rapier, etc.)

## 3. Core Gameplay

## 4. 3D Rendering

## 5. Performance

## 6. UI/UX

## 7. AI-Agent

## 8. State Management

## 9. Backend

## 10. Testing

## 11. Optimization

## 12. Roadmap

âœ… Anforderungen an den Master-Prompt:

VollstÃ¤ndig â€” alle wichtigen Features sind enthalten

Keine WidersprÃ¼che â€” nur eine Richtung, keine Alternativen

Klar strukturiert â€” jede Sektion hat einen klaren Zweck

Beste Ideen vereint â€” das Beste aus allen Prompts, nichts Ã¼berflÃ¼ssiges

ğŸ“Œ Hinweise fÃ¼r dich (KI-Agent):

Beziehe dich auf @TECH_STACK.md â€” wenn du eine Technologie verwendest, prÃ¼fe, ob sie im Stack ist

Vermeide veraltete Patterns â€” z.B. imperatives Three.js, useState in 3D-Komponenten

Bevorzuge R3F-Standard â€” z.B. @react-three/drei, useFrame, Zustand

Sei konkret â€” kein â€mache es besserâ€œ, sondern â€nutze InstancedMesh fÃ¼r 1000 BÃ¤umeâ€œ

ğŸš€ Abschluss:

MASTER_PROMPT.md
+505
# ğŸ® Corona Control Ultimate â€” Master Prompt (R3F Edition)> Konsolidiert aus 42 Prompt-Dateien. WidersprÃ¼che aufgelÃ¶st, Duplikate entfernt, beste Ideen vereint.> Letzte Aktualisierung: 2026-02-21
Die Datei ist geschrieben. Lass mich sie kurz auf Konsistenz prÃ¼fen.
Der Master-Prompt ist vollstÃ¤ndig. Hier ist die Zusammenfassung dessen, was ich aus 42 Dateien extrahiert und konsolidiert habe:
Was der Master-Prompt enthÃ¤lt
505 Zeilen, 12 Sektionen, aus 42 Quelldateien destilliert.
AufgelÃ¶ste WidersprÃ¼che
Widerspruch	Entscheidung	BegrÃ¼ndung
Expo/React Native vs. Vite/Web	Vite/Web	TatsÃ¤chliche Codebasis, R3F-Standard
Jolt Physics vs. Rapier	@react-three/rapier	R3F-idiomatisch, bereits implementiert
WebGPU vs. WebGL2	WebGL2 via R3F	WebGPU hat keinen R3F-Support
Deferred Rendering	Forward + PostProcessing	R3F-Standard, realistisch
NPC-Polys: 3k vs. 8k vs. 35k	8k LOD-0	Realistischer Kompromiss fÃ¼r Browser
FPS: 120@4K vs. 60 vs. 30	60 Desktop, 30 Mobile	Realistisch erreichbar
Zustand v4 vs. v5	v5	Aktuell, bereits im Projekt
LOD: 3 vs. 4 vs. 5 Stufen	5 Stufen	Umfassendste Version, teilweise implementiert
useState vs. Zustand in 3D	Nur Zustand	Keine Re-Renders in useFrame
Raw WebGL/GLSL vs. R3F	R3F-Abstraktion	Deklarativ, wartbar, testbar
Entfernte Duplikate
12Ã— "nutze useFrame fÃ¼r Physik" â†’ 1 klare Regel
8Ã— Polygon-Budget-Tabellen â†’ 1 konsolidierte Tabelle
6Ã— LOD-Distanz-Definitionen â†’ 1 zentrale Quelle (LOD_DISTANCES)
5Ã— Tech-Stack-Listen â†’ 1 verbindliche Tabelle
4Ã— HUD-Layout-Beschreibungen â†’ 1 definitive Version
Verworfene/Veraltete Ideen
Expo/React Native Setup
Eigene WebGL2-Context-Erstellung
Raw GLSL-Shader-Compilation
35.000 Polygone pro NPC (unrealistisch fÃ¼r Browser)
4K native Rendering als "Non-Negotiable"
GOAP als drittes KI-System (Behavior Trees + Utility AI reichen)
Class-Components oder Redux
window-Globals fÃ¼r State-Transfer
Die Datei liegt jetzt unter docs/prompt/MASTER_PROMPT.md und kann ab sofort als einzige Referenz fÃ¼r alle zukÃ¼nftigen Entwicklungssessions genutzt werden.